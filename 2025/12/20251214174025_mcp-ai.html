<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>클로드 코드 MCP 도구 관리: 가성비 끝판왕 AI 세팅법</title>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Mermaid.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <style>
        /* CSS Variables for Dark/Light Mode */
        :root {
            --bg-color-light: #f8f9fa;
            --text-color-light: #212529;
            --primary-color-light: #007bff;
            --secondary-color-light: #6c757d;
            --card-bg-light: #ffffff;
            --border-color-light: #dee2e6;
            --shadow-color-light: rgba(0,0,0,0.1);
            --code-bg-light: #e9ecef;
            --code-text-light: #c82829; /* Monokai red-like */
        }
        [data-theme="dark"] {
            --bg-color-dark: #212529;
            --text-color-dark: #f8f9fa;
            --primary-color-dark: #66b3ff;
            --secondary-color-dark: #adb5bd;
            --card-bg-dark: #343a40;
            --border-color-dark: #495057;
            --shadow-color-dark: rgba(0,0,0,0.3);
            --code-bg-dark: #2c3034;
            --code-text-dark: #e06c75; /* Monokai red-like */
        }

        /* Base Styles */
        body {
            font-family: 'Segoe UI', 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', sans-serif;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            transition: background-color 0.3s, color 0.3s;
            scroll-behavior: smooth;
            
            /* Default to light theme variables */
            --bg-color: var(--bg-color-light);
            --text-color: var(--text-color-light);
            --primary-color: var(--primary-color-light);
            --secondary-color: var(--secondary-color-light);
            --card-bg: var(--card-bg-light);
            --border-color: var(--border-color-light);
            --shadow-color: var(--shadow-color-light);
            --code-bg: var(--code-bg-light);
            --code-text: var(--code-text-light);

            color: var(--text-color);
            background-color: var(--bg-color);
        }

        /* Dark Mode Overrides */
        [data-theme="dark"] body {
            --bg-color: var(--bg-color-dark);
            --text-color: var(--text-color-dark);
            --primary-color: var(--primary-color-dark);
            --secondary-color: var(--secondary-color-dark);
            --card-bg: var(--card-bg-dark);
            --border-color: var(--border-color-dark);
            --shadow-color: var(--shadow-color-dark);
            --code-bg: var(--code-bg-dark);
            --code-text: var(--code-text-dark);
        }

        /* Slide Styling */
        .slide {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 60px 20px;
            text-align: center;
            opacity: 0;
            transform: translateY(50px);
            transition: opacity 0.8s ease-out, transform 0.8s ease-out;
            border-bottom: 1px solid var(--border-color);
            position: relative; /* For background images */
            overflow: hidden;
        }
        .slide.active {
            opacity: 1;
            transform: translateY(0);
        }
        .slide:last-child {
            border-bottom: none;
        }

        /* Typography */
        h1 { font-size: 3.5em; color: var(--primary-color); margin-bottom: 20px; line-height: 1.2; }
        h2 { font-size: 2.5em; color: var(--primary-color); margin-bottom: 20px; line-height: 1.3; }
        h3 { font-size: 1.8em; color: var(--primary-color); margin-bottom: 15px; }
        h4 { font-size: 1.4em; color: var(--primary-color); margin-bottom: 10px; }
        p { max-width: 900px; line-height: 1.7; font-size: 1.15em; margin-bottom: 15px; color: var(--text-color); }
        strong { color: var(--primary-color); }
        .subtitle { font-size: 1.5em; color: var(--secondary-color); margin-bottom: 30px; }

        /* General Elements */
        .icon-large { font-size: 5em; color: var(--primary-color); margin-bottom: 30px; }
        .icon-medium { font-size: 2.5em; color: var(--primary-color); margin-right: 15px; }
        .card {
            background-color: var(--card-bg);
            border-radius: 12px;
            padding: 30px;
            margin: 25px 0;
            box-shadow: 0 6px 20px var(--shadow-color);
            text-align: left;
            max-width: 900px;
            width: 100%;
            border: 1px solid var(--border-color);
        }
        .card h3 { margin-top: 0; }
        .card ul { list-style-type: none; padding-left: 0; margin-top: 15px; }
        .card ul li { margin-bottom: 12px; display: flex; align-items: flex-start; font-size: 1.05em; line-height: 1.6; }
        .card ul li i { margin-right: 12px; color: var(--primary-color); font-size: 1.3em; margin-top: 3px; }
        .flex-container { display: flex; flex-wrap: wrap; justify-content: center; gap: 30px; max-width: 1200px; width: 100%; margin-top: 30px; }
        .flex-item { flex: 1 1 45%; min-width: 300px; }
        
        /* Images */
        .slide img { max-width: 90%; height: auto; border-radius: 12px; box-shadow: 0 8px 24px var(--shadow-color); margin-top: 25px; }
        .youtube-thumbnail { width: 150px; height: auto; border-radius: 8px; margin-top: 20px; box-shadow: 0 4px 12px var(--shadow-color); }

        /* Tables */
        table {
            width: 90%;
            max-width: 1000px;
            margin: 40px auto;
            border-collapse: collapse;
            background-color: var(--card-bg);
            box-shadow: 0 6px 20px var(--shadow-color);
            border-radius: 12px;
            overflow: hidden;
            font-size: 1em;
        }
        th, td {
            padding: 18px;
            border: 1px solid var(--border-color);
            text-align: left;
            color: var(--text-color);
        }
        th {
            background-color: var(--primary-color);
            color: white;
            font-weight: bold;
        }
        tr:nth-child(even) {
            background-color: var(--bg-color);
        }
        tr:hover {
            background-color: var(--border-color);
        }

        /* Code Snippets */
        pre {
            background-color: var(--code-bg);
            color: var(--text-color);
            padding: 15px 20px;
            border-radius: 8px;
            margin: 25px auto;
            max-width: 90%;
            text-align: left;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.95em;
            box-shadow: 0 2px 10px var(--shadow-color);
        }
        code {
            color: var(--code-text);
            background-color: var(--code-bg);
            padding: 3px 6px;
            border-radius: 4px;
        }

        /* Mermaid Diagrams */
        .mermaid {
            margin: 40px auto;
            max-width: 95%;
            background-color: var(--card-bg);
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 6px 20px var(--shadow-color);
            border: 1px solid var(--border-color);
            text-align: center;
        }

        /* Chart.js Container */
        .chart-container {
            width: 90%;
            max-width: 900px;
            height: 400px; /* Fixed height for better chart rendering */
            margin: 40px auto;
            background-color: var(--card-bg);
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 6px 20px var(--shadow-color);
            border: 1px solid var(--border-color);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Callout Boxes */
        .callout {
            background-color: var(--card-bg);
            border-left: 5px solid var(--primary-color);
            padding: 20px 25px;
            margin: 30px auto;
            max-width: 900px;
            text-align: left;
            border-radius: 8px;
            box-shadow: 0 4px 15px var(--shadow-color);
            color: var(--text-color);
        }
        .callout strong { color: var(--primary-color); }

        /* Dark/Light Mode Toggle Button */
        #theme-toggle {
            position: fixed;
            top: 25px;
            right: 25px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 55px;
            height: 55px;
            font-size: 1.6em;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            z-index: 1000;
            transition: background-color 0.3s, transform 0.2s ease-in-out;
        }
        #theme-toggle:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            h1 { font-size: 2.8em; }
            h2 { font-size: 2em; }
            h3 { font-size: 1.6em; }
            p { font-size: 1.05em; }
            .subtitle { font-size: 1.3em; }
            .icon-large { font-size: 4em; }
            .card { padding: 25px; margin: 20px 0; }
            table { font-size: 0.95em; }
            th, td { padding: 15px; }
            .flex-item { flex: 1 1 100%; }
        }

        @media (max-width: 768px) {
            .slide { padding: 40px 15px; }
            h1 { font-size: 2.2em; margin-bottom: 15px; }
            h2 { font-size: 1.8em; margin-bottom: 15px; }
            h3 { font-size: 1.4em; margin-bottom: 10px; }
            p { font-size: 1em; line-height: 1.6; }
            .subtitle { font-size: 1.1em; margin-bottom: 20px; }
            .icon-large { font-size: 3em; margin-bottom: 20px; }
            .icon-medium { font-size: 2em; margin-right: 10px; }
            .card { padding: 20px; margin: 15px 0; }
            .card ul li { font-size: 0.95em; }
            table { width: 100%; font-size: 0.85em; }
            th, td { padding: 12px; }
            .chart-container { height: 350px; padding: 15px; }
            pre { font-size: 0.9em; padding: 12px 15px; }
            .callout { padding: 15px 20px; margin: 20px auto; }
            #theme-toggle { width: 45px; height: 45px; font-size: 1.3em; top: 15px; right: 15px; }
            .youtube-thumbnail { width: 120px; }
        }

        @media (max-width: 480px) {
            h1 { font-size: 1.8em; }
            h2 { font-size: 1.5em; }
            h3 { font-size: 1.2em; }
            p { font-size: 0.95em; }
            .icon-large { font-size: 2.5em; }
            .chart-container { height: 300px; }
        }
    </style>
</head>
<body>
    <button id="theme-toggle" aria-label="Toggle dark/light mode"><i class="fas fa-moon"></i></button>

    <!-- 1. 타이틀 섹션 (1페이지) -->
    <div class="slide" id="slide-title">
        <img src="https://i.ytimg.com/vi/mjqTOtth2zk/mqdefault.jpg" alt="클로드 코드 AI 신기술로 가성비 끝판왕 세팅법" class="youtube-thumbnail">
        <h1>클로드 코드 MCP 도구 관리</h1>
        <p class="subtitle">AI 신기술로 가성비 끝판왕 세팅법 | 토큰 비용 최적화와 작업 효율 극대화 전략</p>
        <p><strong>출처:</strong> 코드깎는노인 (YouTube) | <strong>영상 제목:</strong> 클로드 코드 AI 신기술로 가성비 끝판왕 세팅법</p>
        <p><strong>카테고리:</strong> AI Education | <strong>처리일:</strong> 2025-12-12</p>
    </div>

    <!-- 2. 개요 섹션 (1페이지) -->
    <div class="slide" id="slide-overview">
        <i class="fas fa-robot icon-large"></i>
        <h2>AI 에이전트, 혹시 비효율적으로 쓰고 계신가요?</h2>
        <p>이 영상은 <strong>클로드 코드(Claude Code)</strong>에 새롭게 추가된 <strong>MCP 도구 관리 방식</strong>을 통해 토큰 사용량을 최적화하고 비용 효율성을 극대화하는 방법을 설명합니다.</p>
        <p>핵심은 MCP 도구들을 AI의 작업 공간(컨텍스트)에서 분리하여 필요할 때만 동적으로 로딩하는 <strong>"책상-바닥" 개념</strong>을 도입한 것입니다.</p>
        <div class="card">
            <h3><i class="fas fa-bullseye"></i> 핵심 가치</h3>
            <ul>
                <li><i class="fas fa-dollar-sign"></i> <strong>토큰 사용량 절감:</strong> API 비용 획기적 최적화</li>
                <li><i class="fas fa-flask"></i> <strong>작업 공간 효율성 향상:</strong> AI 응답 정확도 및 성능 개선</li>
            </ul>
        </div>
    </div>

    <!-- 3. 핵심 개념 소개 (2-3페이지) -->
    <div class="slide" id="slide-concept-desk">
        <i class="fas fa-desktop icon-large"></i>
        <h2>AI의 작업 공간: '책상'과 '바닥'의 비유</h2>
        <p>AI 에이전트인 클로드 코드가 작업을 수행하는 방식은 마치 <strong>사람이 일하는 '책상'</strong>에 여러 도구를 올려놓는 것에 비유할 수 있습니다.</p>
        <p>AI는 이 '책상' 위 도구들을 활용해 작업을 진행합니다. 여기서 <strong>'책상'은 AI의 컨텍스트 공간</strong>을 의미합니다.</p>
        <img src="https://i.imgur.com/gK9fI5G.png" alt="AI Desk Analogy" style="max-width: 600px;">
        <p class="subtitle" style="margin-top: 20px;">컨텍스트 공간은 AI의 '작업대'이자 '단기 기억'입니다.</p>
    </div>

    <div class="slide" id="slide-problem-clutter">
        <i class="fas fa-exclamation-triangle icon-large"></i>
        <h2>문제: '책상'이 좁아지는 비효율</h2>
        <p>클로드 코드에 <strong>MCP 도구를 많이 추가할수록</strong>, 이 도구들이 AI의 '책상' 위 공간을 차지하게 됩니다.</p>
        <p>이는 <strong>실질적인 작업을 위한 '여유 공간(Free Space)'을 줄여</strong>, AI의 효율성과 가성비를 떨어뜨리는 주범이 됩니다.</p>
        <div class="card">
            <h3><i class="fas fa-chart-line"></i> 비효율 발생 요인</h3>
            <ul>
                <li><i class="fas fa-tools"></i> <strong>MCP 도구의 공간 점유:</strong> 각 도구의 정의(스키마)가 컨텍스트를 차지합니다.</li>
                <li><i class="fas fa-gas-pump"></i> <strong>토큰 사용량 증가:</strong> 컨텍스트가 길어질수록 더 많은 토큰이 소모되어 API 비용이 상승합니다.</li>
                <li><i class="fas fa-brain"></i> <strong>응답 정확도 저하:</strong> 중요한 정보가 컨텍스트에서 밀려나 AI의 판단력이 흐려질 수 있습니다.</li>
            </ul>
        </div>
        <p><code>/context</code> 명령어를 통해 현재 AI의 '책상' 상태를 직접 확인할 수 있습니다.</p>
    </div>

    <!-- 4. 주요 내용 전개 (4-5페이지) -->
    <div class="slide" id="slide-solution-clear">
        <i class="fas fa-broom icon-large"></i>
        <h2>해결책: '바닥'으로 도구를 내리다</h2>
        <p>앤트로픽(Anthropic)은 이 비효율을 해결하기 위해, '책상' 위에 올려둔 MCP 도구들을 모두 <strong>'바닥'으로 내려놓는 아이디어</strong>를 고안했습니다.</p>
        <p>이를 통해 '책상'의 <strong>여유 공간을 최대로 확보</strong>하여 토큰 사용량을 줄이고 AI의 작업 효율을 높이는 것이 목표입니다.</p>
        <div class="flex-container">
            <div class="card flex-item">
                <h3><i class="fas fa-toolbox"></i> 시스템 도구 (System Tools)</h3>
                <p>AI 에이전트의 핵심 기능으로, 항상 '책상' 위에 배치되는 기본 도구입니다. (예: 파일 수정/읽기, 코드 검색, Bash 명령어 실행)</p>
            </div>
            <div class="card flex-item">
                <h3><i class="fas fa-puzzle-piece"></i> MCP 도구 (MCP Tools)</h3>
                <p>사용자가 필요에 따라 추가하는 확장 도구입니다. 새로운 기능에서는 '바닥'으로 이동하여 관리됩니다. (예: 특정 API 연동 도구)</p>
            </div>
        </div>
    </div>

    <div class="slide" id="slide-how-it-works">
        <i class="fas fa-link icon-large"></i>
        <h2>작동 원리: 'Bash 도구'와 'mcp-cli'의 다리</h2>
        <p>MCP 도구들이 '바닥'으로 내려가면 AI는 어떻게 도구를 찾아 사용할까요? 여기에 <strong>'Bash 도구'와 'mcp-cli'</strong>가 핵심 역할을 합니다.</p>
        <div class="card">
            <h3><i class="fas fa-cogs"></i> 핵심 작동 메커니즘</h3>
            <ul>
                <li><i class="fas fa-terminal"></i> <strong>Bash 도구의 역할:</strong> '책상' 위에 있는 핵심 시스템 도구로, 터미널 명령어를 실행합니다.</li>
                <li><i class="fas fa-search"></i> <strong>mcp-cli 명령어:</strong> AI는 Bash 도구를 사용해 <code>mcp-cli</code>라는 내장 명령어를 실행, '바닥'의 MCP 도구를 검색합니다.</li>
                <li><i class="fas fa-play"></i> <strong>도구 실행:</strong> 필요한 도구를 찾으면, 다시 Bash 도구를 이용해 해당 도구를 실행합니다.</li>
                <li><i class="fas fa-book"></i> <strong>시스템 프롬프트의 지침:</strong> 이 모든 복잡한 과정을 AI가 스스로 수행하도록 돕는 상세 지침이 '시스템 프롬프트'에 명시되어 있습니다.</li>
            </ul>
        </div>
    </div>

    <div class="slide" id="slide-flowchart">
        <h2>정보 흐름도: 기존 방식 vs. mcp-cli 활성화 후</h2>
        <p>mcp-cli 활성화 전후의 컨텍스트 공간 활용 변화를 시각적으로 살펴봅니다.</p>
        <div class="mermaid" data-mermaid-code="
            flowchart TD
                subgraph Before['기존 방식']
                    A1[컨텍스트 공간] --> B1[시스템 도구]
                    A1 --> C1[MCP 도구 1]
                    A1 --> D1[MCP 도구 2]
                    A1 --> E1[MCP 도구 N]
                    A1 --> F1[여유 공간 ↓]
                end
                
                subgraph After['mcp-cli 활성화']
                    A2[컨텍스트 공간] --> B2[시스템 도구]
                    A2 --> G2[시스템 프롬프트 지침]
                    A2 --> F2[여유 공간 ↑↑]
                    H2[외부 저장소] --> C2[MCP 도구들]
                    B2 -->|mcp-cli| C2
                end
                
                Before --> |'활성화'| After
            " id="flowchart-mermaid"></div>
        <p class="subtitle">mcp-cli 활성화 후 '책상' 위에서 MCP 도구들이 사라지고 여유 공간이 대폭 늘어나는 것을 볼 수 있습니다.</p>
    </div>

    <!-- 5. 심층분석 파트 (4-8페이지) -->
    <div class="slide" id="slide-activation">
        <i class="fas fa-unlock-alt icon-large"></i>
        <h2>mcp-cli 기능 활성화 및 확인</h2>
        <p>이 새로운 기능은 숨겨진 '치트키'처럼 특정 명령어를 통해 활성화해야 합니다.</p>
        <div class="card">
            <h3><i class="fas fa-toggle-on"></i> 활성화 절차</h3>
            <ol style="padding-left: 20px;">
                <li><i class="fas fa-stop-circle"></i> 실행 중인 클로드 코드를 <strong>종료</strong>합니다.</li>
                <li><i class="fas fa-keyboard"></i> 터미널에서 특정 활성화 명령어를 <strong>입력</strong>합니다. (영상 참조)</li>
                <li><i class="fas fa-play-circle"></i> 클로드 코드를 <strong>다시 실행</strong>합니다.</li>
            </ol>
            <h3><i class="fas fa-check-circle"></i> 상태 확인</h3>
            <p>기능이 활성화되면 <code>/context</code> 명령어를 통해 '책상' 위에서 MCP 도구들이 사라지고 여유 공간이 확보된 것을 확인할 수 있습니다.</p>
        </div>
        <div class="callout">
            <p><strong>⚠️ 중요한 참고 사항</strong><br>mcp-cli는 현재 <strong>실험적 기능(Experimental Feature)</strong>입니다. 프로덕션 환경에서 사용하기 전에 충분한 테스트를 권장하며, 향후 Anthropic의 업데이트에 따라 동작 방식이 변경될 수 있습니다.</p>
        </div>
    </div>

    <div class="slide" id="slide-cost-analysis">
        <i class="fas fa-chart-bar icon-large"></i>
        <h2>비용-효과 분석: 언제 이득인가?</h2>
        <p>이 기능은 "토큰 사용량을 획기적으로 줄일 수 있는 멋진 방법"이지만, 사용 전 반드시 고려해야 할 사항이 있습니다.</p>
        <div class="chart-container">
            <canvas id="costChart"></canvas>
        </div>
        <p><strong>주요 이점:</strong> 다수의 MCP 도구를 사용할 경우, 작업 공간을 대폭 절약하여 토큰 사용량을 크게 줄이고 비용 효율성을 높일 수 있습니다.</p>
        <p><strong>핵심 고려사항 (Trade-off):</strong> AI에게 도구 사용법을 안내하는 '시스템 프롬프트' 지침 문서 역시 '책상' 위의 공간을 차지합니다. 따라서 도구 수가 적다면 오히려 손해가 될 수 있습니다.</p>
        <div class="callout">
            <p><strong>📌 손익분기점 가이드라인</strong><br>일반적으로 <strong>MCP 도구 5개 이상</strong>을 사용하는 경우 mcp-cli 활성화가 유리합니다. 정확한 손익분기점은 각 도구의 스키마 크기에 따라 달라질 수 있으므로 직접 측정을 권장합니다.</p>
        </div>
    </div>

    <div class="slide" id="slide-insights-1">
        <i class="fas fa-lightbulb icon-large"></i>
        <h2>핵심 인사이트 1: AI 컨텍스트 관리의 경제학</h2>
        <p>AI 에이전트에서 컨텍스트 공간은 <strong>유한한 자원</strong>입니다. 도구 정의가 차지하는 공간과 실제 작업 공간 사이의 <strong>trade-off</strong>를 이해하는 것이 비용 최적화의 핵심입니다.</p>
        <div class="card">
            <h3><i class="fas fa-money-bill-wave"></i> 컨텍스트 = 비용</h3>
            <ul>
                <li><i class="fas fa-coins"></i> 토큰 비용이 곧 운영 비용인 LLM 기반 시스템에서, 컨텍스트 공간을 효율적으로 사용하는 것이 서비스의 <strong>경제적 지속 가능성</strong>을 결정합니다.</li>
                <li><i class="fas fa-memory"></i> 이는 전통적인 소프트웨어 개발의 <strong>메모리 관리 원칙</strong>과 동일한 맥락으로 볼 수 있습니다.</li>
            </ul>
        </div>
    </div>

    <div class="slide" id="slide-insights-2">
        <i class="fas fa-hourglass-half icon-large"></i>
        <h2>핵심 인사이트 2: AI 에이전트의 Lazy Loading</h2>
        <p>웹 개발에서 흔히 사용되는 <strong>Lazy Loading 패턴</strong>이 AI 에이전트 도구 관리에도 효과적으로 적용될 수 있음을 보여줍니다.</p>
        <div class="card">
            <h3><i class="fas fa-cloud-download-alt"></i> Lazy Loading의 확장</h3>
            <ul>
                <li><i class="fas fa-clock"></i> 자주 사용하지 않는 리소스는 필요 시점에 로드하는 것이 효율적이라는 원칙이 AI 도구 관리에도 확장됩니다.</li>
                <li><i class="fas fa-plug"></i> mcp-cli는 필요한 MCP 도구만 동적으로 불러와 사용하여 <strong>초기 로딩 부담을 줄이고</strong> 실제 사용되는 리소스에만 비용을 지불하게 합니다.</li>
            </ul>
        </div>
    </div>

    <div class="slide" id="slide-insights-3">
        <i class="fas fa-layer-group icon-large"></i>
        <h2>핵심 인사이트 3: '도구를 위한 도구' (Meta-tool)</h2>
        <p>Bash 도구가 다른 도구들을 호출하는 <strong>"도구를 위한 도구"</strong> 역할을 수행하는 것은 AI 에이전트 아키텍처에서 메타 레벨의 도구 계층화가 진행되고 있음을 시사합니다.</p>
        <div class="card">
            <h3><i class="fas fa-sitemap"></i> 아키텍처적 진화</h3>
            <ul>
                <li><i class="fas fa-bezier-curve"></i> AI가 직접 MCP 도구를 호출하는 대신, <strong>Bash → mcp-cli → MCP 도구</strong>의 체인 구조를 통해 간접적으로 접근합니다.</li>
                <li><i class="fas fa-network-wired"></i> 이는 복잡한 도구 생태계를 효율적으로 관리하고, AI의 핵심 로직과 도구 로딩 로직을 분리하는 데 기여합니다.</li>
            </ul>
        </div>
    </div>

    <div class="slide" id="slide-tech-deepdive">
        <i class="fas fa-microchip icon-large"></i>
        <h2>기술 심층 분석: 프록시 패턴과 레이지 로딩</h2>
        <p>mcp-cli의 작동 원리는 <strong>프록시 패턴(Proxy Pattern)</strong>과 <strong>레이지 로딩(Lazy Loading)</strong>의 조합으로 이해할 수 있습니다.</p>
        <div class="card">
            <h3><i class="fas fa-code-branch"></i> 핵심 아키텍처 흐름</h3>
            <ol style="padding-left: 20px;">
                <li><i class="fas fa-brain"></i> AI가 특정 MCP 도구가 필요하다고 판단합니다.</li>
                <li><i class="fas fa-terminal"></i> Bash 도구를 사용해 <code>mcp-cli search [도구명]</code> 명령을 실행합니다.</li>
                <li><i class="fas fa-download"></i> 해당 도구의 스키마를 <strong>동적으로 로드</strong>합니다.</li>
                <li><i class="fas fa-play-circle"></i> 다시 Bash를 통해 <code>mcp-cli run [도구명] [파라미터]</code> 형태로 실행합니다.</li>
            </ol>
            <p>이 과정에서 시스템 프롬프트는 mcp-cli 사용법에 대한 상세 지침을 포함하여 AI가 올바른 명령어 구문을 생성하도록 돕습니다.</p>
        </div>
    </div>

    <div class="slide" id="slide-tech-validity">
        <i class="fas fa-check-double icon-large"></i>
        <h2>기술적 타당성 및 고려사항</h2>
        <p>이 접근법은 기술적으로 타당하며, 특히 "도구 수가 많을수록 효율적"이라는 점에서 <strong>확장성(Scalability)</strong> 측면의 이점이 명확합니다.</p>
        <div class="flex-container">
            <div class="card flex-item">
                <h3><i class="fas fa-thumbs-up"></i> 기술적 장점</h3>
                <ul>
                    <li><i class="fas fa-arrow-alt-circle-up"></i> <strong>확장성:</strong> 도구 수가 많아져도 컨텍스트 부담이 적습니다.</li>
                    <li><i class="fas fa-file-invoice-dollar"></i> <strong>비용 효율성:</strong> 불필요한 토큰 낭비를 막습니다.</li>
                </ul>
            </div>
            <div class="card flex-item">
                <h3><i class="fas fa-exclamation-circle"></i> 기술적 고려사항</h3>
                <ul>
                    <li><i class="fas fa-hourglass-start"></i> <strong>지연 시간 증가:</strong> 동적 로딩으로 인한 추가 왕복 지연이 발생할 수 있습니다.</li>
                    <li><i class="fas fa-book"></i> <strong>시스템 프롬프트 오버헤드:</strong> 도구 수가 적을 때는 오히려 비효율적일 수 있습니다.</li>
                    <li><i class="fas fa-search-dollar"></i> <strong>검색 정확도:</strong> AI가 올바른 도구를 '기억'해야 하므로, 도구명이 모호할 경우 실패 가능성이 있습니다.</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="slide" id="slide-practical-apps">
        <i class="fas fa-project-diagram icon-large"></i>
        <h2>실무 적용 전략: 효과적인 문제 해결 영역</h2>
        <p>mcp-cli는 다음 시나리오에서 가장 효과적입니다.</p>
        <div class="card">
            <h3><i class="fas fa-tools"></i> 최적 활용 시나리오</h3>
            <ul>
                <li><i class="fas fa-database"></i> <strong>다중 데이터 소스 통합 프로젝트:</strong> Slack, GitHub, Jira 등 여러 서비스와 연동할 때 각 MCP 도구를 상시 로드할 필요 없이 필요 시에만 사용.</li>
                <li><i class="fas fa-server"></i> <strong>DevOps/인프라 자동화:</strong> AWS, GCP, Kubernetes 등 다양한 인프라 도구를 상황에 따라 선택적으로 사용하는 경우.</li>
                <li><i class="fas fa-code"></i> <strong>대규모 코드베이스 분석:</strong> 여러 언어/프레임워크에 특화된 분석 도구들을 프로젝트 특성에 맞게 동적으로 로드.</li>
            </ul>
        </div>
    </div>

    <div class="slide" id="slide-challenges-tradeoffs">
        <i class="fas fa-balance-scale-right icon-large"></i>
        <h2>예상되는 기술적 난제와 트레이드오프</h2>
        <p>mcp-cli 도입 시 발생할 수 있는 잠재적 문제와 그에 따른 선택 사항을 이해하는 것이 중요합니다.</p>
        <div class="flex-container">
            <div class="card flex-item">
                <h3><i class="fas fa-bug"></i> 기술적 난제</h3>
                <ul>
                    <li><i class="fas fa-times-circle"></i> **도구 호출 실패율 증가:** AI가 정확한 도구명을 기억 못하거나 명령어 구문 오류 발생 가능성.</li>
                    <li><i class="fas fa-wrench"></i> **디버깅 복잡성:** `Bash → mcp-cli → MCP 도구` 체인에서 문제 원인 파악이 어려울 수 있음.</li>
                </ul>
            </div>
            <div class="card flex-item">
                <h3><i class="fas fa-exchange-alt"></i> 트레이드오프</h3>
                <ul>
                    <li><i class="fas fa-tachometer-alt"></i> **응답 속도 vs. 비용 절감:** 동적 로딩으로 인해 첫 번째 도구 호출까지의 지연시간 증가 가능성.</li>
                    <li><i class="fas fa-cogs"></i> **유지보수 복잡성 vs. 효율성:** 도구 관리 로직이 복잡해질 수 있으나, 장기적인 비용 효율성은 향상.</li>
                </ul>
            </div>
        </div>
        <div class="callout">
            <p><strong>💡 팁</strong><br>mcp-cli 활성화 후 일부 복잡한 워크플로우에서 도구 호출 실패율이 증가할 수 있습니다. 이를 완화하려면 시스템 프롬프트에 자주 사용하는 도구 목록을 힌트로 제공하는 것이 효과적입니다.</p>
        </div>
    </div>

    <div class="slide" id="slide-comparison">
        <i class="fas fa-code-compare icon-large"></i>
        <h2>다른 AI 도구와의 비교 분석</h2>
        <p>mcp-cli는 현재 클로드 코드에서만 제공되는 고유 기능으로, 경쟁 도구들은 아직 유사한 동적 로딩 메커니즘을 제공하지 않습니다.</p>
        <table>
            <thead>
                <tr>
                    <th>비교 항목</th>
                    <th>Claude Code (기존)</th>
                    <th>Claude Code (mcp-cli)</th>
                    <th>Cursor</th>
                    <th>GitHub Copilot</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>도구 로딩 방식</strong></td>
                    <td>정적 (전체 로드)</td>
                    <td>동적 (필요 시)</td>
                    <td>정적</td>
                    <td>정적</td>
                </tr>
                <tr>
                    <td><strong>컨텍스트 효율성</strong></td>
                    <td>도구 수에 반비례</td>
                    <td>일정 유지 (매우 우수)</td>
                    <td>고정</td>
                    <td>고정</td>
                </tr>
                <tr>
                    <td><strong>확장성</strong></td>
                    <td>도구 증가 시 제한</td>
                    <td>우수</td>
                    <td>제한적</td>
                    <td>제한적</td>
                </tr>
                <tr>
                    <td><strong>응답 속도</strong></td>
                    <td>빠름</td>
                    <td>약간 느림 (첫 호출)</td>
                    <td>빠름</td>
                    <td>빠름</td>
                </tr>
                <tr>
                    <td><strong>비용 최적화</strong></td>
                    <td>어려움</td>
                    <td>용이</td>
                    <td>N/A</td>
                    <td>N/A</td>
                </tr>
            </tbody>
        </table>
    </div>

    <div class="slide" id="slide-learning-roadmap">
        <i class="fas fa-map-marked-alt icon-large"></i>
        <h2>학습 로드맵: 초급부터 숙련자까지</h2>
        <p>mcp-cli와 클로드 코드를 마스터하기 위한 단계별 학습 경로입니다.</p>
        <div class="flex-container">
            <div class="card flex-item">
                <h3><i class="fas fa-user-graduate"></i> 초급 학습 경로 (2주)</h3>
                <ul>
                    <li><i class="fas fa-book-open"></i> <strong>1주차: 기초 이해</strong>
                        <ul>
                            <li>클로드 코드 설치 및 기본 사용법 숙지</li>
                            <li><code>/context</code> 명령어로 컨텍스트 구조 이해</li>
                            <li>MCP 프로토콜 기본 개념 학습</li>
                        </ul>
                    </li>
                    <li><i class="fas fa-laptop-code"></i> <strong>2주차: mcp-cli 실습</strong>
                        <ul>
                            <li>테스트 환경에서 mcp-cli 활성화</li>
                            <li>활성화 전후 컨텍스트 비교 실습</li>
                            <li>간단한 MCP 도구 호출 테스트</li>
                        </ul>
                    </li>
                </ul>
            </div>
            <div class="card flex-item">
                <h3><i class="fas fa-user-tie"></i> 숙련자 학습 경로 (1주)</h3>
                <ul>
                    <li><i class="fas fa-chart-area"></i> <strong>1-3일: 심화 분석</strong>
                        <ul>
                            <li>mcp-cli 시스템 프롬프트 구조 분석</li>
                            <li>도구별 토큰 사용량 정량 측정</li>
                            <li>손익분기점 계산 스프레드시트 작성</li>
                        </ul>
                    </li>
                    <li><i class="fas fa-rocket"></i> <strong>4-7일: 최적화 및 적용</strong>
                        <ul>
                            <li>팀 환경에 맞는 설정 최적화</li>
                            <li>에러 핸들링 및 폴백 로직 설계</li>
                            <li>프로덕션 적용 및 모니터링 구축</li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
    </div>

    <div class="slide" id="slide-critical-review">
        <i class="fas fa-gavel icon-large"></i>
        <h2>비판적 검토 및 대안</h2>
        <p>mcp-cli의 장점 외에 잠재적 한계점과 고려되지 않은 대안들을 살펴봅니다.</p>
        <div class="flex-container">
            <div class="card flex-item">
                <h3><i class="fas fa-frown"></i> 기술의 한계점과 약점</h3>
                <ul>
                    <li><i class="fas fa-stopwatch"></i> <strong>지연시간 증가:</strong> 도구 검색 및 실행에 추가 단계 필요.</li>
                    <li><i class="fas fa-question-circle"></i> <strong>검색 정확도:</strong> AI가 도구명을 정확히 기억 못할 경우 실패 가능성.</li>
                    <li><i class="fas fa-bug"></i> <strong>디버깅 복잡성:</strong> 다단계 호출 체인에서 문제 원인 파악이 어려울 수 있음.</li>
                    <li><i class="fas fa-flask"></i> <strong>실험적 상태:</strong> 향후 동작 방식 변경 가능성.</li>
                </ul>
            </div>
            <div class="card flex-item">
                <h3><i class="fas fa-puzzle-piece"></i> 고려되지 않은 대안</h3>
                <ul>
                    <li><i class="fas fa-chart-pie"></i> **도구 프로파일링 기반 자동 최적화:** 사용 패턴 분석으로 자주 쓰는 도구는 정적 로드, 가끔 쓰는 도구는 동적 로드하는 하이브리드 방식.</li>
                    <li><i class="fas fa-object-group"></i> **도구 그룹핑:** 관련 도구들을 그룹으로 묶어 그룹 단위로 로드/언로드하여 관리 복잡성 감소.</li>
                    <li><i class="fas fa-server"></i> **서버 사이드 캐싱:** MCP 서버 측에서 자주 사용되는 도구의 응답을 캐싱하여 지연시간 최소화.</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="slide" id="slide-counter-arguments">
        <i class="fas fa-hand-paper icon-large"></i>
        <h2>반대 진영 논리: "모든 도구를 항상 로드해두는 것이 나을 수도 있다"</h2>
        <p>mcp-cli의 효율성에 대한 반대 의견도 존재합니다. 이러한 관점은 다음과 같은 이유를 들 수 있습니다.</p>
        <div class="card">
            <ul>
                <li><i class="fas fa-expand-alt"></i> <strong>LLM 컨텍스트 윈도우 확장:</strong> LLM의 컨텍스트 윈도우가 계속 커지고 있어 공간 제약이 점차 완화될 것입니다.</li>
                <li><i class="fas fa-tools"></i> <strong>동적 로딩의 복잡성:</strong> 동적 로딩의 추가적인 복잡성이 유지보수 비용을 증가시킬 수 있습니다.</li>
                <li><i class="fas fa-bolt"></i> <strong>응답 속도 중요성:</strong> 응답 속도가 중요한 서비스에서는 동적 로딩으로 인한 지연시간 증가가 치명적일 수 있습니다.</li>
            </ul>
        </div>
    </div>

    <div class="slide" id="slide-pitfalls-warnings">
        <i class="fas fa-triangle-exclamation icon-large"></i>
        <h2>잠재적 함정 및 주의사항</h2>
        <p>mcp-cli를 도입하기 전에 반드시 인지해야 할 잠재적 문제점들입니다.</p>
        <div class="card">
            <ul>
                <li><i class="fas fa-exclamation-circle"></i> **기존 워크플로우 실패 가능성:** mcp-cli 활성화 후 기존에 잘 동작하던 워크플로우가 실패할 수 있으므로 충분한 테스트가 필수입니다.</li>
                <li><i class="fas fa-cogs"></i> **시스템 프롬프트 충돌:** 시스템 프롬프트 커스터마이징과 mcp-cli가 충돌할 가능성을 고려해야 합니다.</li>
                <li><i class="fas fa-sync-alt"></i> **버전 업데이트 변화:** 버전 업데이트 시 mcp-cli 동작 방식이 변경될 수 있으므로 릴리스 노트를 주시해야 합니다.</li>
                <li><i class="fas fa-shield-alt"></i> **보안 고려사항:** 동적으로 로드되는 도구의 출처와 보안 취약점을 항상 검토해야 합니다.</li>
            </ul>
        </div>
    </div>

    <div class="slide" id="slide-references">
        <i class="fas fa-graduation-cap icon-large"></i>
        <h2>후속 학습 자료 큐레이션</h2>
        <p>더 깊이 있는 학습을 위한 추천 자료 목록입니다.</p>
        <table>
            <thead>
                <tr>
                    <th>구분</th>
                    <th>자료명</th>
                    <th>설명</th>
                    <th>링크</th>
                    <th>난이도</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>공식 문서</td>
                    <td>Claude Code Documentation</td>
                    <td>Anthropic 공식 클로드 코드 문서</td>
                    <td><a href="https://docs.anthropic.com" target="_blank">docs.anthropic.com</a></td>
                    <td>초급~중급</td>
                </tr>
                <tr>
                    <td>공식 문서</td>
                    <td>MCP Protocol Specification</td>
                    <td>MCP 프로토콜 상세 스펙</td>
                    <td><a href="https://modelcontextprotocol.io" target="_blank">modelcontextprotocol.io</a></td>
                    <td>중급~고급</td>
                </tr>
                <tr>
                    <td>심화 이론</td>
                    <td>LLM Token Economics</td>
                    <td>토큰 비용 구조 및 최적화 전략</td>
                    <td>(검색 권장)</td>
                    <td>중급</td>
                </tr>
                <tr>
                    <td>실습 예제</td>
                    <td>mcp-cli 활용 튜토리얼</td>
                    <td>단계별 설정 및 테스트 가이드</td>
                    <td>(코드깎는노인 채널)</td>
                    <td>초급</td>
                </tr>
                <tr>
                    <td>커뮤니티</td>
                    <td>Claude Code Discord</td>
                    <td>사용자 커뮤니티 및 Q&A</td>
                    <td>(Discord 검색)</td>
                    <td>전체</td>
                </tr>
            </tbody>
        </table>
    </div>

    <!-- 6. 종합 정리 및 시사점 (1페이지) -->
    <div class="slide" id="slide-summary">
        <i class="fas fa-check-circle icon-large"></i>
        <h2>종합 정리: AI 비용 최적화의 미래</h2>
        <p>클로드 코드의 <strong>mcp-cli 기능</strong>은 AI 에이전트의 <strong>컨텍스트 관리</strong>에 대한 혁신적인 접근법을 제시합니다. 이는 단순히 비용을 절감하는 것을 넘어, AI 에이전트 아키텍처 설계의 새로운 방향성을 보여줍니다.</p>
        <div class="card">
            <h3><i class="fas fa-key"></i> 핵심 요약</h3>
            <ul>
                <li><i class="fas fa-compress-alt"></i> <strong>mcp-cli:</strong> MCP 도구를 컨텍스트 외부에서 동적으로 로딩하여 토큰 사용량을 최적화.</li>
                <li><i class="fas fa-coins"></i> <strong>컨텍스트 공간:</strong> 유한한 자원으로, 효율적인 관리가 AI 에이전트 비용 최적화의 핵심.</li>
                <li><i class="fas fa-sync-alt"></i> <strong>동적 로딩:</strong> 웹 개발의 Lazy Loading 패턴을 AI 에이전트 도구 관리에 적용한 사례.</li>
            </ul>
        </div>
        <div class="callout">
            <p><strong>🔥 액션 아이템</strong><br>지금 바로 <code>/context</code> 명령어로 현재 설정을 확인하고, mcp-cli 활성화를 통해 클로드 코드의 잠재력을 최대한 활용해보세요!</p>
        </div>
    </div>

    <script>
        // --- Dark/Light Mode Toggle Logic ---
        const themeToggle = document.getElementById('theme-toggle');
        const body = document.body;

        function setTheme(theme) {
            body.setAttribute('data-theme', theme);
            themeToggle.innerHTML = theme === 'dark' ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
            localStorage.setItem('theme', theme);
            updateChartColors(window.myCostChart);
            updateMermaidTheme();
        }

        // Check for saved theme or system preference on load
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme) {
            setTheme(savedTheme);
        } else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            setTheme('dark');
        } else {
            setTheme('light');
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = body.getAttribute('data-theme');
            setTheme(currentTheme === 'dark' ? 'light' : 'dark');
        });

        // --- Intersection Observer for Scroll Animations ---
        const slides = document.querySelectorAll('.slide');

        const observerOptions = {
            root: null, // viewport
            rootMargin: '0px',
            threshold: 0.3 // Trigger when 30% of the slide is visible
        };

        const slideObserver = new IntersectionObserver((entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('active');
                } else {
                    // Optional: remove 'active' when out of view, for re-animation on scroll back
                    // entry.target.classList.remove('active');
                }
            });
        }, observerOptions);

        slides.forEach(slide => {
            slideObserver.observe(slide);
        });

        // --- Chart.js Integration ---
        let myCostChart; // Global variable for the chart instance

        function getChartColors() {
            const isDark = document.body.getAttribute('data-theme') === 'dark';
            return {
                primary: isDark ? '#66b3ff' : '#007bff',
                secondary: isDark ? '#adb5bd' : '#6c757d',
                text: isDark ? '#f8f9fa' : '#212529',
                grid: isDark ? 'rgba(248, 249, 250, 0.2)' : 'rgba(33, 37, 41, 0.1)',
                tooltipBg: isDark ? '#343a40' : '#ffffff',
                tooltipBorder: isDark ? '#495057' : '#dee2e6',
                tooltipText: isDark ? '#f8f9fa' : '#212529'
            };
        }

        function createCostChart() {
            const ctx = document.getElementById('costChart');
            if (!ctx) return; // Exit if chart canvas not found

            const colors = getChartColors();

            myCostChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['기존 방식 (3 도구)', 'mcp-cli (3 도구)', '기존 방식 (10 도구)', 'mcp-cli (10 도구)'],
                    datasets: [{
                        label: '예상 토큰 사용량 (토큰)',
                        data: [1500, 1300, 5000, 1900], // Illustrative data
                        backgroundColor: [
                            colors.secondary, colors.primary,
                            colors.secondary, colors.primary
                        ],
                        borderColor: [
                            colors.secondary, colors.primary,
                            colors.secondary, colors.primary
                        ],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: '토큰 수',
                                color: colors.text
                            },
                            ticks: { color: colors.text },
                            grid: { color: colors.grid }
                        },
                        x: {
                            ticks: { color: colors.text },
                            grid: { color: colors.grid }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false,
                            labels: { color: colors.text }
                        },
                        title: {
                            display: true,
                            text: 'MCP 도구 수에 따른 토큰 사용량 비교 (예시)',
                            color: colors.text,
                            font: { size: 16 }
                        },
                        tooltip: {
                            backgroundColor: colors.tooltipBg,
                            borderColor: colors.tooltipBorder,
                            borderWidth: 1,
                            titleColor: colors.tooltipText,
                            bodyColor: colors.tooltipText
                        }
                    }
                }
            });
        }

        function updateChartColors(chart) {
            if (!chart) return;
            const colors = getChartColors();
            chart.options.scales.y.title.color = colors.text;
            chart.options.scales.y.ticks.color = colors.text;
            chart.options.scales.y.grid.color = colors.grid;
            chart.options.scales.x.ticks.color = colors.text;
            chart.options.scales.x.grid.color = colors.grid;
            chart.options.plugins.legend.labels.color = colors.text;
            chart.options.plugins.title.color = colors.text;
            chart.options.plugins.tooltip.backgroundColor = colors.tooltipBg;
            chart.options.plugins.tooltip.borderColor = colors.tooltipBorder;
            chart.options.plugins.tooltip.titleColor = colors.tooltipText;
            chart.options.plugins.tooltip.bodyColor = colors.tooltipText;
            chart.data.datasets[0].backgroundColor = [
                colors.secondary, colors.primary,
                colors.secondary, colors.primary
            ];
            chart.data.datasets[0].borderColor = [
                colors.secondary, colors.primary,
                colors.secondary, colors.primary
            ];
            chart.update(); // Re-render the chart with new colors
        }

        // --- Mermaid.js Integration ---
        function updateMermaidTheme() {
            const isDark = document.body.getAttribute('data-theme') === 'dark';
            const colors = getChartColors(); // Reusing chart colors for consistency

            mermaid.initialize({
                startOnLoad: false, // We'll render manually
                theme: isDark ? 'dark' : 'default',
                themeVariables: {
                    primaryColor: colors.primary,
                    primaryTextColor: isDark ? '#212529' : '#f8f9fa', // Text on primary background
                    primaryBorderColor: colors.primary,
                    lineColor: colors.secondary,
                    textColor: colors.text,
                    mainBkg: colors.card_bg, // Main background for nodes/elements
                    nodeBorder: colors.border,
                    clusterBkg: isDark ? '#2c3034' : '#f0f0f0',
                    clusterBorder: colors.secondary
                }
            });

            // Re-render all mermaid diagrams
            document.querySelectorAll('.mermaid').forEach((el, index) => {
                const graphDefinition = el.getAttribute('data-mermaid-code');
                if (graphDefinition) {
                    // Generate a unique ID for the SVG
                    const svgId = `mermaid-svg-${index}`;
                    mermaid.render(svgId, graphDefinition).then(({ svg }) => {
                        el.innerHTML = svg;
                    }).catch(error => {
                        console.error('Mermaid rendering failed for:', el, error);
                        el.innerHTML = `<pre style="color:red;">Error rendering diagram: ${error.message}</pre>`;
                    });
                }
            });
        }

        // Initialize on DOMContentLoaded
        document.addEventListener('DOMContentLoaded', () => {
            createCostChart();
            updateMermaidTheme(); // Initial render of mermaid diagrams
        });
    </script>
</body>
</html>